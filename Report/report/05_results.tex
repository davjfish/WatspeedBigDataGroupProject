\section{Results}


\subsection{Database Design and Implementation}

After an initial inspection of the data using exploratory tools from Pandas~\cite{pandas}, a SQL schema of five tables was devised and drafted.
The five resulting tables and their descriptions are as follows:

\begin{itemize}
    \item Category - categorical descriptions of the types of calls received (e.g., car accident)
    \item Township - township name and state (e.g., Kings Township, PA)
    \item ResponseUnit - complete list of units responding to emergency calls  (e.g., Station 123, EMS)
    \item ResponseType - the response unit type (e.g., EMS, Traffic, or Fire)
    \item EmergencyCall - this is the primary data table and used to store information about emergency calls received. It has several links to the above tables.
\end{itemize}

Figure~\ref{fig:sqldiagram} presents a visual portrayal of the five above table and the relationships between them.
In addition to the foreign key constraints between tables, indexes were added to each table to improve performance.
Unique constraints were placed on fields in tables were duplication of data entry was not wanted.
For example, we only wanted there to be a single entry for \"back pain\" in the Category table and only a single entry for \"EMS\" in the ResponseType table.
The Township and ResponseUnit tables both had unique together constraints across two columns.
In the case of the former, only a single entry for a combination of township name and state was desired and for the latter,
only a single combination of response unit and station name was desired.
Finally, the complete SQL definitions of the above tables and indices can be found in \hyperref[sec:app1]{Appendix 1}.

The file size of the original CSV downloaded from Kaggle was approximately 123 MB\@.
Following the creation of the database and subsequent ingestion of the data, the file size was reduced to approximately 75 MB\@, including all the indices.
This confirms that our schema has indeed achieved greater storage efficiency than the CSV flat file.








Specifically, in addition to HTML Django templates, the reactive front-end of the application
will be  developed using Vue.js~\cite{vue}, Leaflet~\cite{leaflet} and Charts.js~\cite{charts}.


On the backend of the application a parser class was defined in order to handle the incoming CSV and its digestion into the database.
- leveraging bulk creates

The Django web-application will also be used to define a Parser class that will be used to ingest the CSV data.
Th




\pagebreak



\begin{figure}
    \includegraphics[width=\linewidth]{SQL.png}
    \caption{A visual depiction of the five tables in our SQL database design.}
    \label{fig:sqldiagram}
\end{figure}

